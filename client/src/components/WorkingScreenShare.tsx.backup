import React, { useState, useRef, useEffect } from 'react';
import { io, Socket } from 'socket.io-client';
import { 
  Monitor, 
  Square, 
  Users, 
  MessageCircle, 
  Send,
  Copy,
  Check,
  Mic,
  MicOff,
  Video,
  VideoOff,
  Settings,
  Download,
  Play,
  Pause,
  RotateCcw,
  Maximize,
  Minimize
} from 'lucide-react';
import { v4 as uuidv4 } from 'uuid';

interface Message {
  id: string;
  userId: string;
  userName: string;
  text: string;
  timestamp: number;
}

interface Participant {
  id: string;
  name: string;
  isPresenting: boolean;
}

export default function WorkingScreenShare() {
  const [userId] = useState(() => uuidv4());
  const [userName, setUserName] = useState(() => `User ${Math.random().toString(36).substr(2, 4)}`);
  const [roomId, setRoomId] = useState('');
  const [isInRoom, setIsInRoom] = useState(false);
  const [isPresenting, setIsPresenting] = useState(false);
  const [messages, setMessages] = useState<Message[]>([]);
  const [messageInput, setMessageInput] = useState('');
  const [participants, setParticipants] = useState<Participant[]>([]);
  const [copied, setCopied] = useState(false);
  const [showJoinModal, setShowJoinModal] = useState(true);
  const [audioEnabled, setAudioEnabled] = useState(true);
  const [videoEnabled, setVideoEnabled] = useState(true);
  const [microphoneEnabled, setMicrophoneEnabled] = useState(false);
  const [streamError, setStreamError] = useState<string | null>(null);
  const [fps, setFps] = useState(30);
  const [isRecording, setIsRecording] = useState(false);
  const [recordedChunks, setRecordedChunks] = useState<Blob[]>([]);
  const [showSettings, setShowSettings] = useState(false);
  const [isFullScreen, setIsFullScreen] = useState(false);
  const [sharingCamera, setSharingCamera] = useState(false);
  const [cameraStream, setCameraStream] = useState<MediaStream | null>(null);
  const [quality, setQuality] = useState('1080p');
  const [showCursor, setShowCursor] = useState(true);
  const [connectionStatus, setConnectionStatus] = useState<'connecting' | 'connected' | 'failed' | 'offline'>('offline');
  const [turnServerStatus, setTurnServerStatus] = useState<'testing' | 'available' | 'unavailable'>('testing');
  const [crossNetworkMode, setCrossNetworkMode] = useState(false);
  const [connectionRetries, setConnectionRetries] = useState(0);

  // Enhanced ICE servers configuration for cross-network connectivity
  const getICEServers = (turnOnly = false) => {
    if (turnOnly) {
      // TURN-only configuration for cross-network scenarios with verified servers
      return {
        iceServers: [
          // Metered TURN - highly reliable for cross-network
          { 
            urls: [
              'turn:a01.cosyvoice.org:3478',
              'turn:a01.cosyvoice.org:3478?transport=tcp',
              'turn:a01.cosyvoice.org:443',
              'turn:a01.cosyvoice.org:443?transport=tcp'
            ],
            username: 'turn',
            credential: 'turn'
          },
          // OpenRelay - verified working TURN server
          { 
            urls: [
              'turn:openrelay.metered.ca:80',
              'turn:openrelay.metered.ca:443',
              'turn:openrelay.metered.ca:443?transport=tcp'
            ],
            username: 'openrelayproject',
            credential: 'openrelayproject'
          },
          // Xirsys global TURN infrastructure (fallback)
          { 
            urls: [
              'turn:global.xirsys.com:80?transport=udp',
              'turn:global.xirsys.com:3478?transport=udp',
              'turn:global.xirsys.com:80?transport=tcp',
              'turn:global.xirsys.com:3478?transport=tcp'
            ],
            username: 'malzahar',
            credential: 'malzahar'
          },
          // Numb TURN server for backup
          { 
            urls: [
              'turn:numb.viagenie.ca:3478',
              'turn:numb.viagenie.ca:3478?transport=tcp'
            ],
            username: 'webrtc@live.com',
            credential: 'muazkh'
          },
          // Twilio STUN/TURN for additional reliability
          {
            urls: [
              'turn:global.stun.twilio.com:3478?transport=udp',
              'turn:global.stun.twilio.com:3478?transport=tcp',
              'turn:global.stun.twilio.com:443?transport=tcp'
            ],
            username: 'dc2d2894b88c15701a0a62488e73f3ac73819c2b3ab3042dd53',
            credential: 'YX0M9OTQ+oZuaW0t9OIoyF+qYkwFGwLEIEDWCg=='
          }
        ],
        iceCandidatePoolSize: 30,
        bundlePolicy: 'max-bundle' as RTCBundlePolicy,
        rtcpMuxPolicy: 'require' as RTCRtcpMuxPolicy,
        iceTransportPolicy: 'relay' as RTCIceTransportPolicy, // Force TURN relay only
        iceGatheringTimeout: 60000 // Extended timeout for cross-network TURN
      };
    }

    // Standard configuration with both STUN and TURN
    return {
      iceServers: [
        // Google STUN servers for NAT traversal
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun2.l.google.com:19302' },
        { urls: 'stun:stun3.l.google.com:19302' },
        { urls: 'stun:stun4.l.google.com:19302' },
        // Additional reliable STUN servers
        { urls: 'stun:stun.services.mozilla.com' },
        { urls: 'stun:stun.ekiga.net' },
        { urls: 'stun:stun.stunprotocol.org:3478' },
        { urls: 'stun:stun.nextcloud.com:443' },
        { urls: 'stun:stun.counterpath.com:3478' },
        { urls: 'stun:stun.antisip.com' },
        { urls: 'stun:global.stun.twilio.com:3478' },
        // Multiple reliable TURN servers for cross-network connectivity
        { 
          urls: ['turn:openrelay.metered.ca:80', 'turn:openrelay.metered.ca:443'],
          username: 'openrelayproject',
          credential: 'openrelayproject'
        },
        { 
          urls: 'turn:openrelay.metered.ca:443?transport=tcp',
          username: 'openrelayproject',
          credential: 'openrelayproject'
        },
        // Coturn public servers
        { 
          urls: ['turn:coturn.cc:3478', 'turn:coturn.cc:3478?transport=tcp'],
          username: 'coturn',
          credential: 'coturn'
        },
        // Additional reliable TURN servers
        { 
          urls: ['turn:relay.backups.cz', 'turn:relay.backups.cz?transport=tcp'],
          username: 'webrtc',
          credential: 'webrtc'
        },
        // FreeStun.net TURN servers
        { 
          urls: ['turn:freestun.net:5349', 'turn:freestun.net:3478'],
          username: 'free',
          credential: 'free'
        },
        // TURN servers with different ports for firewall bypass
        { 
          urls: ['turn:numb.viagenie.ca:3478', 'turn:numb.viagenie.ca:3478?transport=tcp'],
          username: 'webrtc@live.com',
          credential: 'muazkh'
        },
        // Additional enterprise-grade TURN servers
        { 
          urls: ['turn:turn.bistri.com:80', 'turn:turn.anyfirewall.com:443'],
          username: 'homeo',
          credential: 'homeo'
        }
      ],
      iceCandidatePoolSize: 50, // Significantly increase candidate pool for better connectivity
      bundlePolicy: 'max-bundle' as RTCBundlePolicy,
      rtcpMuxPolicy: 'require' as RTCRtcpMuxPolicy,
      iceTransportPolicy: 'all' as RTCIceTransportPolicy, // Allow both STUN and TURN
      iceGatheringTimeout: 45000 // Extended timeout for cross-network scenarios
    };
  };

  // Test TURN server connectivity with enhanced detection
  const testTurnServers = async () => {
    try {
      console.log('üîç Testing TURN server connectivity...');
      setTurnServerStatus('testing');
      
      const testConfig = getICEServers();
      const testPc = new RTCPeerConnection(testConfig);
      
      let turnServerWorking = false;
      let candidateCount = 0;
      
      testPc.onicecandidate = (event) => {
        if (event.candidate) {
          candidateCount++;
          console.log('üßä Test ICE candidate:', event.candidate.candidate);
          
          // Check for various types of TURN relay candidates
          if (event.candidate.candidate.includes('typ relay') || 
              event.candidate.candidate.includes('relay') ||
              (event.candidate.candidate.includes('turn') && event.candidate.candidate.includes('udp'))) {
            console.log('‚úÖ TURN server is working - relay candidate found');
            turnServerWorking = true;
            setTurnServerStatus('available');
          }
          
          // Also consider TURN working if we get many candidates (indicating server responsiveness)
          if (candidateCount > 10 && !turnServerWorking) {
            console.log('‚úÖ TURN servers responsive - many candidates gathered');
            turnServerWorking = true;
            setTurnServerStatus('available');
          }
        }
      };

      testPc.onicegatheringstatechange = () => {
        console.log('üßä ICE gathering state:', testPc.iceGatheringState);
      };

      // Create a data channel to trigger ICE gathering
      testPc.createDataChannel('test');
      const offer = await testPc.createOffer();
      await testPc.setLocalDescription(offer);
      
      // Extended wait time for TURN server detection with cross-network analysis
      setTimeout(() => {
        if (!turnServerWorking) {
          if (candidateCount >= 5) {
            console.log('‚ö†Ô∏è TURN relay not detected, but servers responding - enabling cross-network mode as precaution');
            setTurnServerStatus('available');
            setCrossNetworkMode(true); // Preemptively enable for cross-network scenarios
          } else {
            console.log('‚ö†Ô∏è Limited TURN server response - cross-network connectivity will likely fail');
            setTurnServerStatus('unavailable');
            setCrossNetworkMode(true); // Force TURN-only mode
          }
        } else {
          console.log('‚úÖ TURN relay servers fully functional - optimal for all network scenarios');
          setTurnServerStatus('available');
        }
        testPc.close();
      }, 15000); // Increased timeout for better detection
      
    } catch (error) {
      console.error('‚ùå TURN server test failed:', error);
      setTurnServerStatus('unavailable');
    }
  };

  const videoContainerRef = useRef<HTMLDivElement>(null);
  const currentStreamRef = useRef<MediaStream | null>(null);
  const chatMessagesRef = useRef<HTMLDivElement>(null);
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const socketRef = useRef<Socket | null>(null);
  const peerConnectionsRef = useRef<Map<string, RTCPeerConnection>>(new Map());
  const [remoteStreams, setRemoteStreams] = useState<Map<string, MediaStream>>(new Map());

  // Initialize TURN server testing
  useEffect(() => {
    testTurnServers();
  }, []);

  // Initialize Socket.IO
  useEffect(() => {
    if (isInRoom && !socketRef.current) {
      const socket = io();
      socketRef.current = socket;

      // Join room
      socket.emit('join-room', { roomId, userName });

      // Listen for participants updates
      socket.on('participants-updated', (participantsList: Participant[]) => {
        setParticipants(participantsList);
      });

      // Listen for new messages
      socket.on('new-message', (message: Message) => {
        setMessages(prev => [...prev, message]);
      });

      // WebRTC signaling listeners
      socket.on('presenter-started', async ({ presenterId, presenterName }) => {
        console.log('üë• Presenter started:', presenterName, 'ID:', presenterId);
        if (presenterId !== socket.id) {
          // Viewers just wait for offers from presenter - don't create connections yet
          console.log('üì∫ Viewer ready to receive stream from presenter');
        }
      });

      socket.on('presenter-stopped', ({ presenterId }) => {
        console.log('üë• Presenter stopped');
        closePeerConnection(presenterId);
        setRemoteStreams(prev => {
          const newStreams = new Map(prev);
          newStreams.delete(presenterId);
          return newStreams;
        });
      });

      socket.on('webrtc-offer', async ({ offer, senderId }) => {
        console.log('üìû Received WebRTC offer from:', senderId);
        await handleWebRTCOffer(offer, senderId);
      });

      socket.on('webrtc-answer', async ({ answer, senderId }) => {
        console.log('üìû Received WebRTC answer from:', senderId);
        await handleWebRTCAnswer(answer, senderId);
      });

      socket.on('webrtc-ice-candidate', async ({ candidate, senderId }) => {
        console.log('üßä Received ICE candidate from:', senderId);
        await handleICECandidate(candidate, senderId);
      });

      return () => {
        if (socketRef.current) {
          socketRef.current.emit('leave-room', { roomId, userName });
          socketRef.current.disconnect();
          socketRef.current = null;
        }
      };
    }
  }, [isInRoom, roomId, userName]);

  // Auto-scroll chat messages
  useEffect(() => {
    if (chatMessagesRef.current) {
      chatMessagesRef.current.scrollTop = chatMessagesRef.current.scrollHeight;
    }
  }, [messages]);

  const generateRoomId = () => {
    const id = Math.random().toString(36).substring(2, 8).toUpperCase();
    setRoomId(id);
  };

  const copyRoomId = async () => {
    if (roomId) {
      await navigator.clipboard.writeText(roomId);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    }
  };

  const joinRoom = () => {
    if (!roomId.trim() || !userName.trim()) return;
    
    setIsInRoom(true);
    setShowJoinModal(false);
  };

  const leaveRoom = () => {
    if (socketRef.current) {
      socketRef.current.emit('leave-room', { roomId, userName });
      socketRef.current.disconnect();
      socketRef.current = null;
    }
    
    // Clean up peer connections
    peerConnectionsRef.current.forEach(pc => pc.close());
    peerConnectionsRef.current.clear();
    setRemoteStreams(new Map());
    
    if (isPresenting) {
      stopScreenShare();
    }
    
    setIsInRoom(false);
    setParticipants([]);
    setMessages([]);
    setShowJoinModal(true);
  };

  const createVideoElement = (stream: MediaStream, isRemoteStream = false): HTMLVideoElement => {
    const video = document.createElement('video');
    
    // Set essential properties for cross-browser compatibility
    // Only mute presenter's own video (to prevent feedback), allow audio for remote streams
    video.muted = !isRemoteStream;
    video.autoplay = true;
    video.playsInline = true;
    video.controls = false;
    video.loop = false;
    video.defaultMuted = !isRemoteStream;
    
    // Set volume for remote streams
    if (isRemoteStream) {
      video.volume = 1.0; // Full volume for remote audio
    }
    
    // Style the video element
    video.style.width = '100%';
    video.style.height = '100%';
    video.style.objectFit = 'contain';
    video.style.backgroundColor = '#000';
    video.style.borderRadius = '8px';
    video.style.display = 'block';
    video.style.margin = 'auto';
    
    // Add debugging attributes  
    video.setAttribute('webkit-playsinline', 'true');
    video.setAttribute('x-webkit-airplay', 'allow');
    
    console.log('üì∫ Creating video element with stream:', {
      streamId: stream.id,
      active: stream.active,
      tracks: stream.getTracks().length,
      videoTracks: stream.getVideoTracks().length,
      audioTracks: stream.getAudioTracks().length
    });
    
    // Track state changes for debugging
    stream.getVideoTracks().forEach((track, index) => {
      console.log(`Video track ${index}:`, {
        id: track.id,
        kind: track.kind,
        enabled: track.enabled,
        readyState: track.readyState,
        label: track.label
      });
    });
    
    // CRITICAL: Set srcObject and handle events
    video.srcObject = stream;
    
    // Add comprehensive event listeners for debugging
    video.addEventListener('loadstart', () => console.log('üìπ Video loadstart'));
    video.addEventListener('loadedmetadata', () => console.log('üìπ Video metadata loaded'));
    video.addEventListener('canplay', () => console.log('üìπ Video can play'));
    video.addEventListener('playing', () => console.log('‚úÖ Video is playing'));
    video.addEventListener('error', (e) => console.error('‚ùå Video error:', e));
    video.addEventListener('stalled', () => console.warn('‚ö†Ô∏è Video stalled'));
    video.addEventListener('waiting', () => console.log('‚è≥ Video waiting'));
    
    // Immediate play attempt
    const playVideo = () => {
      video.play()
        .then(() => {
          console.log('‚úÖ Video playing immediately after creation');
          setStreamError(null);
        })
        .catch((error) => {
          console.log('‚ÑπÔ∏è Video autoplay blocked, will require user interaction:', error.name);
          setStreamError('Click the video area to start playback');
        });
    };
    
    // Try to play immediately and after a small delay
    playVideo();
    setTimeout(playVideo, 100);
    
    return video;
  };

  const startScreenShare = async () => {
    try {
      console.log('üé¨ Starting screen share...');
      setStreamError(null);
      
      // Get quality-based constraints
      const getQualityConstraints = (quality: string) => {
        switch (quality) {
          case '1080p':
            return { width: { ideal: 1920 }, height: { ideal: 1080 } };
          case '720p':
            return { width: { ideal: 1280 }, height: { ideal: 720 } };
          case '480p':
            return { width: { ideal: 854 }, height: { ideal: 480 } };
          default:
            return { width: { ideal: 1920 }, height: { ideal: 1080 } };
        }
      };
      
      const constraints: DisplayMediaStreamConstraints = {
        video: {
          frameRate: { ideal: fps, max: fps },
          ...getQualityConstraints(quality),
          cursor: showCursor ? 'always' : 'never' as any,
          displaySurface: 'monitor' as any,
          logicalSurface: true
        },
        audio: audioEnabled || microphoneEnabled
      };

      console.log('üéØ Screen share constraints:', JSON.stringify(constraints, null, 2));
      const stream = await navigator.mediaDevices.getDisplayMedia(constraints);
      
      // Verify and log actual stream settings
      const videoTrack = stream.getVideoTracks()[0];
      const actualSettings = videoTrack?.getSettings();
      console.log('‚úÖ Got screen share stream:', {
        id: stream.id,
        active: stream.active,
        videoTracks: stream.getVideoTracks().length,
        audioTracks: stream.getAudioTracks().length,
        actualSettings: actualSettings,
        requestedQuality: quality,
        requestedFPS: fps
      });
      
      // Force settings if they don't match (constraint the track)
      if (actualSettings && videoTrack) {
        const targetConstraints = {
          frameRate: { ideal: fps, max: fps },
          ...getQualityConstraints(quality)
        };
        
        try {
          await videoTrack.applyConstraints(targetConstraints);
          console.log('‚úÖ Applied constraints to force exact settings');
          
          // Log final settings
          const finalSettings = videoTrack.getSettings();
          console.log('üéØ Final stream settings:', finalSettings);
          
          // Verify the settings match our requirements
          if (finalSettings.frameRate !== fps) {
            console.warn(`‚ö†Ô∏è FPS mismatch: requested ${fps}, got ${finalSettings.frameRate}`);
          }
          if (finalSettings.width !== getQualityConstraints(quality).width.ideal) {
            console.warn(`‚ö†Ô∏è Resolution mismatch: requested ${getQualityConstraints(quality).width.ideal}x${getQualityConstraints(quality).height.ideal}, got ${finalSettings.width}x${finalSettings.height}`);
          }
        } catch (constraintError) {
          console.warn('‚ö†Ô∏è Could not apply exact constraints:', constraintError);
        }
      }
      
      currentStreamRef.current = stream;
      
      // Add presenter video without clearing remote videos
      if (videoContainerRef.current) {
        // Only remove existing presenter video, keep remote videos
        const existingPresenterVideo = videoContainerRef.current.querySelector('#presenter-video');
        if (existingPresenterVideo) {
          existingPresenterVideo.remove();
        }
        
        const videoElement = createVideoElement(stream);
        videoElement.id = 'presenter-video';
        videoElement.style.position = 'absolute';
        videoElement.style.top = '0';
        videoElement.style.left = '0';
        videoElement.style.width = '100%';
        videoElement.style.height = '100%';
        videoElement.style.zIndex = '1';
        
        videoContainerRef.current.appendChild(videoElement);
        
        // Immediate play attempt with DOM interaction
        requestAnimationFrame(() => {
          videoElement.play().then(() => {
            console.log('‚úÖ Presenter video playing after DOM insertion');
            setStreamError(null);
          }).catch(() => {
            console.log('‚ÑπÔ∏è Click video area to enable playback');
          });
        });
      }

      setIsPresenting(true);
      
      // Notify other participants and setup WebRTC for immediate sharing
      if (socketRef.current) {
        socketRef.current.emit('start-presenting', { roomId, userName });
        
        // Send stream to all existing participants as presenter with cross-network optimization
        setTimeout(async () => {
          setConnectionStatus('connecting');
          for (const participant of participants) {
            if (participant.id !== socketRef.current?.id && socketRef.current) {
              console.log('üîó Presenter creating connection to viewer:', participant.name, participant.id, crossNetworkMode ? '(cross-network mode)' : '');
              
              // Create new peer connection with forced TURN-only for cross-network
              const pc = await createPeerConnection(participant.id, true); // Force TURN-only for better cross-network reliability
              if (!pc) continue;
              
              // Enhanced connection monitoring with automatic retry
              pc.onconnectionstatechange = () => {
                const state = pc.connectionState;
                console.log(`üîó Screen share connection state for ${participant.name}:`, state);
                
                if (state === 'connected') {
                  setConnectionStatus('connected');
                  console.log(`‚úÖ Screen share connected successfully to ${participant.name}`);
                } else if (state === 'failed' || state === 'disconnected') {
                  console.log(`‚ùå Screen share connection failed to ${participant.name}, attempting TURN-only retry`);
                  setConnectionRetries(prev => prev + 1);
                  setCrossNetworkMode(true);
                  
                  // Retry with TURN-only after cleanup
                  setTimeout(async () => {
                    if (peerConnectionsRef.current.has(participant.id)) {
                      peerConnectionsRef.current.get(participant.id)?.close();
                      peerConnectionsRef.current.delete(participant.id);
                    }
                    
                    console.log(`üîÑ Retrying connection to ${participant.name} with TURN-only`);
                    await createPresenterOfferWithTurnOnly(participant.id, participant.name);
                  }, 2000);
                }
              };
              
              if (currentStreamRef.current) {
                // Add all tracks from current stream
                currentStreamRef.current.getTracks().forEach(track => {
                  console.log('‚ûï Adding track to peer connection:', track.kind, track.id);
                  pc.addTrack(track, currentStreamRef.current!);
                });
                
                // Create enhanced offer with cross-network optimizations
                const offer = await pc.createOffer({
                  offerToReceiveAudio: true,
                  offerToReceiveVideo: true,
                  iceRestart: crossNetworkMode,
                  voiceActivityDetection: false // Better for cross-network
                });
                await pc.setLocalDescription(offer);
                
                console.log('üì§ Sending optimized offer to viewer:', participant.id);
                socketRef.current.emit('webrtc-offer', {
                  roomId,
                  offer,
                  targetId: participant.id,
                  crossNetworkMode: crossNetworkMode
                });
                
                // Monitor offer success and retry if needed
                setTimeout(() => {
                  if (pc.connectionState !== 'connected' && pc.connectionState !== 'connecting') {
                    console.log(`‚ö†Ô∏è Offer to ${participant.name} may have failed, will retry automatically`);
                  }
                }, 8000);
              }
            }
          }
        }, 500);
      }

      // Handle stream ending
      stream.getVideoTracks()[0].addEventListener('ended', () => {
        console.log('üîö Screen share ended');
        stopScreenShare();
      });

    } catch (error) {
      console.error('‚ùå Failed to start screen share:', error);
      setStreamError('Failed to start screen sharing. Please grant permission and try again.');
    }
  };

  const startRecording = () => {
    if (!currentStreamRef.current) return;

    try {
      // Force high quality recording with proper bitrate
      const videoBitsPerSecond = quality === '1080p' ? 8000000 : quality === '720p' ? 4000000 : 2000000;
      const audioBitsPerSecond = 128000;
      
      const options = {
        mimeType: 'video/webm;codecs=vp9',
        videoBitsPerSecond,
        audioBitsPerSecond
      };

      const mediaRecorder = new MediaRecorder(currentStreamRef.current, options);

      mediaRecorderRef.current = mediaRecorder;
      setRecordedChunks([]);

      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          setRecordedChunks(prev => [...prev, event.data]);
        }
      };

      mediaRecorder.onstop = () => {
        console.log('Recording stopped');
      };

      // Record with FPS-based timing
      const interval = Math.round(1000 / fps);
      mediaRecorder.start(interval);
      setIsRecording(true);

      const message: Message = {
        id: uuidv4(),
        userId: 'system',
        userName: 'System',
        text: `${userName} started recording at ${quality} ${fps}fps`,
        timestamp: Date.now()
      };
      setMessages(prev => [...prev, message]);

    } catch (error) {
      console.error('Failed to start recording:', error);
      setStreamError('Recording not supported on this browser');
    }
  };

  const stopRecording = () => {
    if (mediaRecorderRef.current && isRecording) {
      mediaRecorderRef.current.stop();
      setIsRecording(false);

      const message: Message = {
        id: uuidv4(),
        userId: 'system',
        userName: 'System',
        text: `${userName} stopped recording`,
        timestamp: Date.now()
      };
      setMessages(prev => [...prev, message]);
    }
  };

  const downloadRecording = () => {
    if (recordedChunks.length === 0) return;

    const blob = new Blob(recordedChunks, { type: 'video/webm' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `screen-recording-${new Date().toISOString().slice(0, 19)}.webm`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    const message: Message = {
      id: uuidv4(),
      userId: 'system',
      userName: 'System',
      text: `Recording downloaded`,
      timestamp: Date.now()
    };
    setMessages(prev => [...prev, message]);
  };

  const toggleFullScreen = async () => {
    if (!isFullScreen) {
      // Enter full screen - target the entire document body for true fullscreen
      try {
        if (document.documentElement.requestFullscreen) {
          await document.documentElement.requestFullscreen();
        } else if ((document.documentElement as any).webkitRequestFullscreen) {
          await (document.documentElement as any).webkitRequestFullscreen();
        } else if ((document.documentElement as any).msRequestFullscreen) {
          await (document.documentElement as any).msRequestFullscreen();
        }
        
        // Will be handled by fullscreen change event
        
      } catch (error) {
        console.error('Failed to enter full screen:', error);
      }
    } else {
      // Exit full screen
      try {
        if (document.exitFullscreen) {
          await document.exitFullscreen();
        } else if ((document as any).webkitExitFullscreen) {
          await (document as any).webkitExitFullscreen();
        } else if ((document as any).msExitFullscreen) {
          await (document as any).msExitFullscreen();
        }
        
        // Will be handled by fullscreen change event
        
      } catch (error) {
        console.error('Failed to exit full screen:', error);
      }
    }
  };

  // Listen for fullscreen change events and escape key
  useEffect(() => {
    const handleFullScreenChange = () => {
      const isCurrentlyFullScreen = !!(
        document.fullscreenElement ||
        (document as any).webkitFullscreenElement ||
        (document as any).msFullscreenElement
      );
      setIsFullScreen(isCurrentlyFullScreen);
      
      // Apply YouTube-style fullscreen styling
      if (isCurrentlyFullScreen) {
        // Hide everything except video container
        document.body.style.overflow = 'hidden';
        document.body.style.backgroundColor = '#000';
        
        // Create fullscreen overlay
        const overlay = document.createElement('div');
        overlay.id = 'fullscreen-overlay';
        overlay.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100vw;
          height: 100vh;
          background: #000;
          z-index: 9998;
          display: flex;
          align-items: center;
          justify-content: center;
        `;
        
        // Move video to fullscreen overlay
        const videoContainer = videoContainerRef.current;
        if (videoContainer) {
          const video = videoContainer.querySelector('video');
          if (video) {
            const videoClone = video.cloneNode(true) as HTMLVideoElement;
            videoClone.style.cssText = `
              width: 100vw;
              height: 100vh;
              object-fit: contain;
              background: #000;
              border-radius: 0;
            `;
            videoClone.srcObject = video.srcObject;
            videoClone.muted = true;
            videoClone.autoplay = true;
            videoClone.playsInline = true;
            
            overlay.appendChild(videoClone);
            document.body.appendChild(overlay);
            
            // Play the cloned video
            videoClone.play().catch(console.error);
          }
        }
        
        // Add exit fullscreen button
        const exitButton = document.createElement('button');
        exitButton.innerHTML = '‚úï Exit Full Screen';
        exitButton.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: rgba(0, 0, 0, 0.8);
          color: white;
          border: none;
          padding: 12px 20px;
          border-radius: 6px;
          cursor: pointer;
          z-index: 9999;
          font-size: 14px;
          font-weight: 500;
        `;
        exitButton.onmouseover = () => {
          exitButton.style.background = 'rgba(0, 0, 0, 0.9)';
        };
        exitButton.onmouseout = () => {
          exitButton.style.background = 'rgba(0, 0, 0, 0.8)';
        };
        exitButton.onclick = toggleFullScreen;
        document.body.appendChild(exitButton);
        
      } else {
        // Exit fullscreen - cleanup
        document.body.style.overflow = '';
        document.body.style.backgroundColor = '';
        
        // Remove fullscreen overlay
        const overlay = document.getElementById('fullscreen-overlay');
        if (overlay) {
          overlay.remove();
        }
        
        // Remove all exit buttons that might be leftover
        document.querySelectorAll('button').forEach(btn => {
          if (btn.innerHTML && btn.innerHTML.includes('Exit Full Screen')) {
            btn.remove();
          }
        });
      }
    };

    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === 'Escape' && isFullScreen) {
        toggleFullScreen();
      }
    };

    document.addEventListener('fullscreenchange', handleFullScreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullScreenChange);
    document.addEventListener('msfullscreenchange', handleFullScreenChange);
    document.addEventListener('keydown', handleKeyDown);

    return () => {
      document.removeEventListener('fullscreenchange', handleFullScreenChange);
      document.removeEventListener('webkitfullscreenchange', handleFullScreenChange);
      document.removeEventListener('msfullscreenchange', handleFullScreenChange);
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [isFullScreen]);

  // Camera and microphone sharing functions
  const startCameraShare = async () => {
    try {
      console.log('üìπ Starting camera share...');
      setStreamError(null);
      
      const getQualityConstraints = (quality: string) => {
        switch (quality) {
          case '1080p':
            return { width: { ideal: 1920 }, height: { ideal: 1080 } };
          case '720p':
            return { width: { ideal: 1280 }, height: { ideal: 720 } };
          case '480p':
            return { width: { ideal: 854 }, height: { ideal: 480 } };
          default:
            return { width: { ideal: 1920 }, height: { ideal: 1080 } };
        }
      };
      
      const constraints: MediaStreamConstraints = {
        video: {
          ...getQualityConstraints(quality),
          frameRate: { ideal: fps, max: fps }
        },
        audio: microphoneEnabled ? {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true,
          sampleRate: 44100
        } : false
      };

      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      
      // Add microphone stream separately if needed for better audio quality
      if (microphoneEnabled && !stream.getAudioTracks().length) {
        try {
          const micStream = await navigator.mediaDevices.getUserMedia({ 
            audio: {
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true,
              sampleRate: 44100
            }
          });
          
          // Add mic tracks to the main stream
          micStream.getAudioTracks().forEach(track => {
            stream.addTrack(track);
          });
          console.log('‚úÖ Added separate microphone audio track');
        } catch (micError) {
          console.warn('‚ö†Ô∏è Could not add separate microphone:', micError);
        }
      }
      console.log('‚úÖ Got camera stream:', {
        id: stream.id,
        active: stream.active,
        videoTracks: stream.getVideoTracks().length,
        audioTracks: stream.getAudioTracks().length
      });
      
      setCameraStream(stream);
      currentStreamRef.current = stream;
      
      // Add camera video without clearing remote videos
      if (videoContainerRef.current) {
        // Only remove existing presenter video, keep remote videos
        const existingPresenterVideo = videoContainerRef.current.querySelector('#presenter-video');
        if (existingPresenterVideo) {
          existingPresenterVideo.remove();
        }
        
        const videoElement = createVideoElement(stream);
        videoElement.id = 'presenter-video';
        videoElement.style.position = 'absolute';
        videoElement.style.top = '0';
        videoElement.style.left = '0';
        videoElement.style.width = '100%';
        videoElement.style.height = '100%';
        videoElement.style.zIndex = '1';
        videoContainerRef.current.appendChild(videoElement);
        
        // Immediate play attempt
        requestAnimationFrame(() => {
          videoElement.play().then(() => {
            console.log('‚úÖ Camera video playing');
            setStreamError(null);
          }).catch(() => {
            console.log('‚ÑπÔ∏è Click video area to enable camera playback');
          });
        });
      }

      setSharingCamera(true);
      setIsPresenting(true);
      
      // Notify other participants
      if (socketRef.current) {
        socketRef.current.emit('start-presenting', { roomId, userName });
        
        // Send camera stream to all existing participants
        setTimeout(async () => {
          for (const participant of participants) {
            if (participant.id !== socketRef.current?.id && socketRef.current) {
              console.log('üîó Presenter creating camera connection to viewer:', participant.name, participant.id);
              
              // Create new peer connection for each participant
              const pc = new RTCPeerConnection(getICEServers());
              
              peerConnectionsRef.current.set(participant.id, pc);

              // Enhanced connection monitoring for camera share
              pc.onconnectionstatechange = () => {
                console.log(`üîó Camera share connection state for ${participant.name}:`, pc.connectionState);
              };

              pc.onicecandidate = (event) => {
                if (event.candidate && socketRef.current) {
                  console.log(`üßä Sending camera share ICE candidate to ${participant.name}:`, event.candidate.candidate);
                  socketRef.current.emit('webrtc-ice-candidate', {
                    roomId,
                    candidate: event.candidate,
                    targetId: participant.id
                  });
                }
              };
              
              if (currentStreamRef.current) {
                // Add all tracks from camera stream
                currentStreamRef.current.getTracks().forEach(track => {
                  console.log('‚ûï Adding camera track to peer connection:', track.kind, track.id);
                  pc.addTrack(track, currentStreamRef.current!);
                });
                
                // Create and send offer
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                
                console.log('üì§ Sending camera offer to viewer:', participant.id);
                socketRef.current.emit('webrtc-offer', {
                  roomId,
                  offer,
                  targetId: participant.id
                });
              }
            }
          }
        }, 500);
      }

      // Handle stream ending
      const videoTrack = stream.getVideoTracks()[0];
      if (videoTrack) {
        videoTrack.addEventListener('ended', () => {
          console.log('üîö Camera share ended');
          stopCameraShare();
        });
      }

    } catch (error) {
      console.error('‚ùå Failed to start camera share:', error);
      setStreamError('Failed to access camera. Please grant permission and try again.');
    }
  };

  const stopCameraShare = () => {
    console.log('üõë Stopping camera share...');
    
    if (cameraStream) {
      cameraStream.getTracks().forEach(track => {
        track.stop();
      });
      setCameraStream(null);
    }

    if (currentStreamRef.current) {
      currentStreamRef.current.getTracks().forEach(track => {
        track.stop();
      });
      currentStreamRef.current = null;
    }

    if (videoContainerRef.current) {
      videoContainerRef.current.innerHTML = '';
    }

    setSharingCamera(false);
    setIsPresenting(false);
    setStreamError(null);
    
    // Clean up peer connections
    peerConnectionsRef.current.forEach(pc => pc.close());
    peerConnectionsRef.current.clear();
    
    if (socketRef.current) {
      socketRef.current.emit('stop-presenting', { roomId, userName });
    }
  };

  const stopScreenShare = () => {
    console.log('üõë Stopping screen share...');
    
    // Stop recording if active
    if (isRecording) {
      stopRecording();
    }
    
    if (currentStreamRef.current) {
      currentStreamRef.current.getTracks().forEach(track => {
        track.stop();
      });
      currentStreamRef.current = null;
    }

    if (videoContainerRef.current) {
      videoContainerRef.current.innerHTML = '';
    }

    setIsPresenting(false);
    setStreamError(null);
    mediaRecorderRef.current = null;
    
    // Clean up peer connections and notify other participants
    peerConnectionsRef.current.forEach(pc => pc.close());
    peerConnectionsRef.current.clear();
    
    if (socketRef.current) {
      socketRef.current.emit('stop-presenting', { roomId, userName });
    }
  };

  const sendMessage = () => {
    if (!messageInput.trim() || !socketRef.current) return;

    socketRef.current.emit('send-message', {
      roomId,
      message: messageInput.trim(),
      userName
    });

    setMessageInput('');
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  };

  // Detect cross-network scenario and force TURN mode
  const detectCrossNetwork = (candidates: string[]) => {
    const hasPrivateIP = candidates.some(candidate => 
      candidate.includes('192.168.') || 
      candidate.includes('10.') || 
      candidate.includes('172.16.') ||
      candidate.includes('172.17.') ||
      candidate.includes('172.18.') ||
      candidate.includes('172.19.') ||
      candidate.includes('172.20.') ||
      candidate.includes('172.21.') ||
      candidate.includes('172.22.') ||
      candidate.includes('172.23.') ||
      candidate.includes('172.24.') ||
      candidate.includes('172.25.') ||
      candidate.includes('172.26.') ||
      candidate.includes('172.27.') ||
      candidate.includes('172.28.') ||
      candidate.includes('172.29.') ||
      candidate.includes('172.30.') ||
      candidate.includes('172.31.')
    );
    
    const hasPublicIP = candidates.some(candidate => 
      candidate.includes('typ srflx') && 
      !candidate.includes('192.168.') && 
      !candidate.includes('10.') && 
      !candidate.includes('172.')
    );
    
    return hasPrivateIP && hasPublicIP;
  };

  // WebRTC functions with cross-network detection
  const createPeerConnection = async (peerId: string, forceTurnOnly = false) => {
    try {
      // Use TURN-only if cross-network mode is detected or forced
      const useTurnOnly = crossNetworkMode || forceTurnOnly || connectionRetries > 2;
      const peerConnection = new RTCPeerConnection(getICEServers(useTurnOnly));
      
      if (useTurnOnly) {
        console.log('üåê Using TURN-only configuration for cross-network connectivity');
      }

      peerConnectionsRef.current.set(peerId, peerConnection);

      // Enhanced connection state monitoring with cross-network recovery
      peerConnection.onconnectionstatechange = () => {
        console.log(`üîó Connection state changed for ${peerId}:`, peerConnection.connectionState);
        
        if (peerConnection.connectionState === 'connected') {
          setConnectionStatus('connected');
          setConnectionRetries(0); // Reset retries on success
          console.log(`‚úÖ Connection established successfully for ${peerId}`);
        } else if (peerConnection.connectionState === 'connecting') {
          setConnectionStatus('connecting');
        } else if (peerConnection.connectionState === 'failed' || peerConnection.connectionState === 'disconnected') {
          console.log(`‚ùå Connection failed for ${peerId}, attempting comprehensive restart...`);
          setConnectionStatus('failed');
          setConnectionRetries(prev => prev + 1);
          
          // Automatic cross-network detection and TURN-only fallback
          const currentRetries = connectionRetries + 1;
          console.log(`üîÑ Connection attempt ${currentRetries} for ${peerId}`);
          
          if (currentRetries >= 2) {
            console.log(`üåê Enabling cross-network mode due to connection failures`);
            setCrossNetworkMode(true);
          }
          
          // Strategy 1: ICE restart (fast recovery) - only for first failure
          if (currentRetries === 1) {
            setTimeout(() => {
              try {
                console.log(`üîÑ Strategy 1: ICE restart for ${peerId}`);
                if (peerConnection.connectionState !== 'closed') {
                  peerConnection.restartIce();
                }
              } catch (error) {
                console.log(`‚ùå ICE restart failed for ${peerId}:`, error);
              }
            }, 1000);
          }
          
          // Strategy 2: Fresh connection with TURN-only for cross-network
          setTimeout(() => {
            console.log(`üîÑ Strategy 2: Creating fresh connection with TURN-only for ${peerId}`);
            if (peerConnectionsRef.current.has(peerId)) {
              peerConnectionsRef.current.get(peerId)?.close();
              peerConnectionsRef.current.delete(peerId);
            }
            // Force TURN-only mode for cross-network scenarios
            createPeerConnection(peerId, true);
          }, currentRetries === 1 ? 5000 : 2000);
          
          // Strategy 3: Advanced TURN-only configuration with extended timeout
          setTimeout(() => {
            console.log(`üîÑ Strategy 3: Advanced TURN-only fallback for ${peerId}`);
            
            if (peerConnectionsRef.current.has(peerId)) {
              peerConnectionsRef.current.get(peerId)?.close();
              peerConnectionsRef.current.delete(peerId);
            }
            
            // Create new connection with TURN-only configuration
            const fallbackPc = new RTCPeerConnection(getICEServers(true));
            peerConnectionsRef.current.set(peerId, fallbackPc);
            
            // Set up enhanced monitoring for TURN-only connection
            fallbackPc.onconnectionstatechange = () => {
              console.log(`üîó TURN-only connection state for ${peerId}:`, fallbackPc.connectionState);
              if (fallbackPc.connectionState === 'connected') {
                setConnectionStatus('connected');
                console.log(`‚úÖ TURN-only connection successful for ${peerId}`);
              }
            };
            
            fallbackPc.onicecandidate = (event) => {
              if (event.candidate && socketRef.current) {
                console.log(`üßä TURN-only ICE candidate for ${peerId}:`, event.candidate.candidate);
                socketRef.current.emit('webrtc-ice-candidate', {
                  roomId,
                  candidate: event.candidate,
                  targetId: peerId
                });
              }
            };
            
            fallbackPc.ontrack = (event) => {
              console.log('üé• TURN-only received remote stream from:', peerId);
              const remoteStream = event.streams[0];
              setRemoteStreams(prev => {
                const newStreams = new Map(prev);
                newStreams.set(peerId, remoteStream);
                return newStreams;
              });
              
              // Add video element for TURN-only stream
              if (videoContainerRef.current && remoteStream) {
                const existingVideo = videoContainerRef.current.querySelector(`#remote-video-${peerId}`);
                if (existingVideo) {
                  (existingVideo as HTMLVideoElement).srcObject = remoteStream;
                  return;
                }
                
                const videoElement = createVideoElement(remoteStream, true);
                videoElement.id = `remote-video-${peerId}`;
                videoElement.style.position = 'absolute';
                videoElement.style.top = '0';
                videoElement.style.left = '0';
                videoElement.style.width = '100%';
                videoElement.style.height = '100%';
                videoElement.style.zIndex = '1';
                
                videoContainerRef.current.appendChild(videoElement);
                
                videoElement.play().then(() => {
                  console.log('‚úÖ TURN-only video playing successfully');
                  setStreamError(null);
                }).catch((error) => {
                  console.log('‚ö†Ô∏è TURN-only video autoplay blocked:', error.message);
                  setStreamError('Click the video area to start playback');
                });
              }
            };
            
            console.log(`üîÑ TURN-only connection created for ${peerId}`);
          }, 10000);
        }
      };

      peerConnection.oniceconnectionstatechange = () => {
        console.log(`üßä ICE connection state for ${peerId}:`, peerConnection.iceConnectionState);
        if (peerConnection.iceConnectionState === 'failed') {
          console.log(`‚ùå ICE connection failed for ${peerId} - will attempt recovery`);
        } else if (peerConnection.iceConnectionState === 'connected') {
          console.log(`‚úÖ ICE connection established for ${peerId}`);
          setConnectionStatus('connected');
        } else if (peerConnection.iceConnectionState === 'completed') {
          console.log(`üéâ ICE connection completed for ${peerId}`);
          setConnectionStatus('connected');
        } else if (peerConnection.iceConnectionState === 'checking') {
          setConnectionStatus('connecting');
        }
      };

      peerConnection.onicegatheringstatechange = () => {
        console.log(`üì° ICE gathering state for ${peerId}:`, peerConnection.iceGatheringState);
        if (peerConnection.iceGatheringState === 'complete') {
          console.log(`‚úÖ ICE gathering completed for ${peerId}`);
        }
      };

      peerConnection.onicecandidate = (event) => {
        if (event.candidate && socketRef.current) {
          console.log(`üßä Sending ICE candidate for ${peerId}:`, event.candidate.candidate);
          socketRef.current.emit('webrtc-ice-candidate', {
            roomId,
            candidate: event.candidate,
            targetId: peerId
          });
        } else if (!event.candidate) {
          console.log(`üßä ICE gathering complete for ${peerId}`);
        }
      };

      peerConnection.ontrack = (event) => {
        console.log('üé• Received remote stream from:', peerId);
        console.log('üîç Event details:', {
          streams: event.streams.length,
          track: event.track.kind,
          trackId: event.track.id,
          trackEnabled: event.track.enabled,
          trackReadyState: event.track.readyState
        });
        
        const [remoteStream] = event.streams;
        if (!remoteStream) {
          console.error('‚ùå No remote stream in ontrack event');
          return;
        }
        
        // Verify the stream has active tracks
        const videoTracks = remoteStream.getVideoTracks();
        const audioTracks = remoteStream.getAudioTracks();
        console.log('üîç Stream details:', {
          streamId: remoteStream.id,
          active: remoteStream.active,
          videoTracks: videoTracks.length,
          audioTracks: audioTracks.length,
          videoTrackEnabled: videoTracks[0]?.enabled,
          videoTrackReadyState: videoTracks[0]?.readyState,
          audioTrackEnabled: audioTracks[0]?.enabled,
          audioTrackReadyState: audioTracks[0]?.readyState
        });
        
        // Log each track for detailed debugging
        remoteStream.getTracks().forEach((track, index) => {
          console.log(`üéµ Track ${index}:`, {
            kind: track.kind,
            enabled: track.enabled,
            readyState: track.readyState,
            muted: track.muted,
            id: track.id,
            label: track.label
          });
        });
        
        setRemoteStreams(prev => new Map(prev.set(peerId, remoteStream)));
        
        // Display remote stream for viewers only - ensure we're not the presenter
        if (videoContainerRef.current && !isPresenting) {
          console.log('üì∫ Viewer displaying remote stream from presenter');
          console.log('üîç Video container state:', {
            hasContainer: !!videoContainerRef.current,
            containerChildren: videoContainerRef.current?.children.length,
            isPresenting
          });
          
          // Check if this remote video already exists to avoid duplicates
          const existingVideo = videoContainerRef.current.querySelector(`#remote-video-${peerId}`);
          if (existingVideo) {
            console.log('üì∫ Remote video already exists, updating stream');
            (existingVideo as HTMLVideoElement).srcObject = remoteStream;
            
            // Force play after stream update with enhanced debugging
            (existingVideo as HTMLVideoElement).play()
              .then(() => {
                console.log('‚úÖ Updated existing remote video playing successfully');
                setStreamError(null);
              })
              .catch((error) => {
                console.log('‚ö†Ô∏è Updated existing remote video play failed:', {
                  name: error.name,
                  message: error.message,
                  code: error.code
                });
                setStreamError('Click the video area to start playback');
              });
            return;
          }
          
          // Only clear if no remote videos exist - preserve existing remote streams
          const hasRemoteVideos = videoContainerRef.current.querySelector('[id^="remote-video-"]');
          if (!hasRemoteVideos) {
            console.log('üóëÔ∏è Clearing video container for first remote stream');
            videoContainerRef.current.innerHTML = '';
          }
          
          // Create a new video element with enhanced configuration
          console.log('üÜï Creating new video element for remote stream');
          const videoElement = createVideoElement(remoteStream, true);
          videoElement.id = `remote-video-${peerId}`;
          videoElement.style.position = 'absolute';
          videoElement.style.top = '0';
          videoElement.style.left = '0';
          videoElement.style.width = '100%';
          videoElement.style.height = '100%';
          videoElement.style.zIndex = '1';
          videoElement.style.backgroundColor = '#000';
          
          // Add comprehensive video event listeners for debugging
          videoElement.onloadedmetadata = () => {
            console.log('üìä Remote video metadata loaded:', {
              videoWidth: videoElement.videoWidth,
              videoHeight: videoElement.videoHeight,
              duration: videoElement.duration,
              currentTime: videoElement.currentTime,
              readyState: videoElement.readyState
            });
          };
          
          videoElement.onplay = () => {
            console.log('‚ñ∂Ô∏è Remote video started playing');
          };
          
          videoElement.onpause = () => {
            console.log('‚è∏Ô∏è Remote video paused');
          };
          
          videoElement.onerror = (error) => {
            console.error('‚ùå Remote video element error:', error);
          };
          
          videoElement.onabort = () => {
            console.log('‚ö†Ô∏è Remote video loading aborted');
          };
          
          videoElement.onstalled = () => {
            console.log('‚ö†Ô∏è Remote video stalled');
          };
          
          videoElement.onwaiting = () => {
            console.log('‚è≥ Remote video waiting for data');
          };
          
          videoElement.oncanplay = () => {
            console.log('‚úÖ Remote video can play');
          };
          
          videoElement.oncanplaythrough = () => {
            console.log('‚úÖ Remote video can play through');
          };
          
          videoContainerRef.current.appendChild(videoElement);
          console.log('‚úÖ Remote video element added to container');
          
          // Enhanced play attempts with comprehensive debugging
          let playAttempts = 0;
          const attemptPlay = () => {
            playAttempts++;
            if (playAttempts > 15) {
              console.log('‚ùå Max play attempts reached for remote video');
              setStreamError('Click the video area to start playback');
              return;
            }
            
            console.log(`üé¨ Play attempt ${playAttempts} for remote video`);
            console.log('üîç Video element state before play:', {
              readyState: videoElement.readyState,
              networkState: videoElement.networkState,
              currentTime: videoElement.currentTime,
              paused: videoElement.paused,
              ended: videoElement.ended,
              srcObject: !!videoElement.srcObject,
              videoWidth: videoElement.videoWidth,
              videoHeight: videoElement.videoHeight
            });
            
            const playPromise = videoElement.play();
            
            if (playPromise !== undefined) {
              playPromise
                .then(() => {
                  console.log('‚úÖ Remote video playing successfully for viewer');
                  console.log('üîç Video playing state:', {
                    currentTime: videoElement.currentTime,
                    duration: videoElement.duration,
                    videoWidth: videoElement.videoWidth,
                    videoHeight: videoElement.videoHeight
                  });
                  setStreamError(null);
                })
                .catch((error) => {
                  console.log(`‚ö†Ô∏è Remote video play failed (attempt ${playAttempts}):`, {
                    name: error.name,
                    message: error.message,
                    code: error.code
                  });
                  
                  if (playAttempts === 1) {
                    // Add multiple interaction handlers on first failure
                    const playOnInteraction = () => {
                      console.log('üëÜ User interaction detected for remote video, attempting play');
                      videoElement.play()
                        .then(() => {
                          console.log('‚úÖ Remote video playing after user interaction');
                          setStreamError(null);
                        })
                        .catch((err) => {
                          console.log('‚ùå Remote video still failed after interaction:', err);
                          setStreamError('Video playback issue - try refreshing the page');
                        });
                    };
                    
                    videoElement.addEventListener('click', playOnInteraction, { once: true });
                    videoElement.addEventListener('touchstart', playOnInteraction, { once: true });
                    document.addEventListener('click', playOnInteraction, { once: true });
                    
                    setStreamError('Click anywhere to enable video playback');
                  }
                  
                  // Escalating retry intervals with better timing
                  if (playAttempts <= 5) {
                    setTimeout(attemptPlay, 300);
                  } else if (playAttempts <= 10) {
                    setTimeout(attemptPlay, 1000);
                  } else if (playAttempts <= 15) {
                    setTimeout(attemptPlay, 2000);
                  }
                });
            } else {
              console.log('‚ö†Ô∏è Play promise undefined for remote video, retrying...');
              setTimeout(attemptPlay, 500);
            }
          };
          
          // Start first attempt immediately
          console.log('üöÄ Starting remote video play attempts');
          attemptPlay();
        }
      };

      // Don't create offers here - let the presenter initiate connections

      return peerConnection;
    } catch (error) {
      console.error('‚ùå Error creating peer connection:', error);
    }
  };

  const handleWebRTCOffer = async (offer: RTCSessionDescriptionInit, senderId: string) => {
    try {
      console.log('üìû Handling WebRTC offer from:', senderId, 'as presenter:', isPresenting);
      console.log('üìã Offer details:', { type: offer.type, sdp: offer.sdp?.substring(0, 200) + '...' });
      
      let peerConnection = peerConnectionsRef.current.get(senderId);
      if (!peerConnection) {
        console.log('üÜï Creating new peer connection for:', senderId);
        peerConnection = await createPeerConnection(senderId);
      }

      if (peerConnection && socketRef.current) {
        console.log('üîç Current signaling state:', peerConnection.signalingState);
        
        // Handle different signaling states properly
        if (peerConnection.signalingState === 'stable' || peerConnection.signalingState === 'have-local-offer') {
          // If we have a local offer, we need to restart the connection
          if (peerConnection.signalingState === 'have-local-offer') {
            console.log('üîÑ Restarting connection due to offer collision');
            peerConnection.close();
            peerConnectionsRef.current.delete(senderId);
            peerConnection = await createPeerConnection(senderId);
          }
          
          console.log('üì• Setting remote description (offer)');
          await peerConnection.setRemoteDescription(offer);
          console.log('‚úÖ Remote description set successfully');
          
          console.log('üìù Creating answer...');
          const answer = await peerConnection.createAnswer({
            offerToReceiveAudio: true,
            offerToReceiveVideo: true
          });
          console.log('‚úÖ Answer created');
          
          console.log('üì• Setting local description (answer)');
          await peerConnection.setLocalDescription(answer);
          console.log('‚úÖ Local description set successfully');

          console.log('üì§ Sending answer to:', senderId);
          socketRef.current.emit('webrtc-answer', {
            roomId,
            answer,
            targetId: senderId
          });
          
          console.log('‚úÖ WebRTC offer handling completed successfully');
        } else {
          console.warn('‚ö†Ô∏è Ignoring offer due to signaling state:', peerConnection.signalingState);
          // Force restart if in invalid state
          if (peerConnection.signalingState === 'closed') {
            console.log('üîÑ Restarting closed connection');
            peerConnection.close();
            peerConnectionsRef.current.delete(senderId);
            peerConnection = await createPeerConnection(senderId);
            // Retry the offer handling
            setTimeout(() => handleWebRTCOffer(offer, senderId), 100);
          }
        }
      } else {
        console.error('‚ùå Missing peer connection or socket for offer handling');
      }
    } catch (error) {
      console.error('‚ùå Error handling WebRTC offer:', error);
      console.error('üîç Error details:', {
        name: error.name,
        message: error.message,
        stack: error.stack?.substring(0, 500)
      });
      
      // Attempt recovery
      try {
        console.log('üîß Attempting recovery from offer handling error');
        const peerConnection = peerConnectionsRef.current.get(senderId);
        if (peerConnection) {
          peerConnection.close();
          peerConnectionsRef.current.delete(senderId);
        }
        
        // Create fresh connection and retry
        setTimeout(async () => {
          console.log('üîÑ Retrying offer handling after error recovery');
          await handleWebRTCOffer(offer, senderId);
        }, 1000);
      } catch (recoveryError) {
        console.error('‚ùå Recovery failed:', recoveryError);
      }
    }
  };

  const handleWebRTCAnswer = async (answer: RTCSessionDescriptionInit, senderId: string) => {
    try {
      const peerConnection = peerConnectionsRef.current.get(senderId);
      if (peerConnection && peerConnection.signalingState === 'have-local-offer') {
        console.log('üìû Setting remote answer from:', senderId);
        await peerConnection.setRemoteDescription(answer);
      } else {
        console.warn('‚ö†Ô∏è Ignoring answer due to wrong signaling state:', peerConnection?.signalingState);
      }
    } catch (error) {
      console.error('‚ùå Error handling WebRTC answer:', error);
    }
  };

  const handleICECandidate = async (candidate: RTCIceCandidateInit, senderId: string) => {
    try {
      const peerConnection = peerConnectionsRef.current.get(senderId);
      if (peerConnection) {
        await peerConnection.addIceCandidate(candidate);
      }
    } catch (error) {
      console.error('‚ùå Error handling ICE candidate:', error);
    }
  };

  // Create presenter offer with TURN-only for cross-network retry
  const createPresenterOfferWithTurnOnly = async (participant: any) => {
    try {
      console.log('üåê Creating TURN-only offer for cross-network to:', participant.name);
      
      if (!currentStreamRef.current || !socketRef.current) {
        console.log('‚ùå No stream or socket available for TURN-only retry');
        return;
      }
      
      // Force TURN-only configuration
      const pc = await createPeerConnection(participant.id, true);
      if (!pc) return;
      
      // Add enhanced connection monitoring for TURN-only
      pc.onconnectionstatechange = () => {
        const state = pc.connectionState;
        console.log(`üåê TURN-only connection state for ${participant.name}:`, state);
        
        if (state === 'connected') {
          setConnectionStatus('connected');
          console.log(`‚úÖ TURN-only connection successful to ${participant.name}`);
        } else if (state === 'failed') {
          console.log(`‚ùå TURN-only connection also failed to ${participant.name}`);
          setConnectionStatus('failed');
        }
      };
      
      // Add stream tracks
      currentStreamRef.current.getTracks().forEach(track => {
        console.log('‚ûï Adding track to TURN-only connection:', track.kind);
        pc.addTrack(track, currentStreamRef.current!);
      });
      
      // Create TURN-only optimized offer
      const offer = await pc.createOffer({
        offerToReceiveAudio: true,
        offerToReceiveVideo: true,
        iceRestart: true,
        voiceActivityDetection: false
      });
      
      await pc.setLocalDescription(offer);
      
      console.log('üì§ Sending TURN-only offer to:', participant.id);
      socketRef.current.emit('webrtc-offer', {
        roomId,
        offer,
        targetId: participant.id,
        crossNetworkMode: true,
        turnOnly: true
      });
      
    } catch (error) {
      console.error('‚ùå Error creating TURN-only offer:', error);
    }
  };

  const closePeerConnection = (peerId: string) => {
    const peerConnection = peerConnectionsRef.current.get(peerId);
    if (peerConnection) {
      peerConnection.close();
      peerConnectionsRef.current.delete(peerId);
    }
  };

  // Create presenter offer with TURN-only configuration for cross-network reliability
  const createPresenterOfferWithTurnOnly = async (participantId: string, participantName: string) => {
    try {
      console.log(`üåê Creating TURN-only connection to ${participantName} (${participantId})`);
      
      // Create new peer connection with forced TURN-only mode
      const pc = new RTCPeerConnection(getICEServers(true));
      peerConnectionsRef.current.set(participantId, pc);
      
      // Add enhanced logging for TURN-only connections
      pc.onicecandidate = (event) => {
        if (event.candidate && socketRef.current) {
          console.log(`üßä TURN-only ICE candidate for ${participantName}:`, event.candidate.candidate);
          socketRef.current.emit('webrtc-ice-candidate', {
            roomId,
            candidate: event.candidate,
            targetId: participantId
          });
        }
      };
      
      pc.onconnectionstatechange = () => {
        console.log(`üîó TURN-only connection state for ${participantName}:`, pc.connectionState);
        if (pc.connectionState === 'connected') {
          console.log(`‚úÖ TURN-only connection successful to ${participantName}`);
          setConnectionStatus('connected');
          setConnectionRetries(0);
        } else if (pc.connectionState === 'failed') {
          console.log(`‚ùå TURN-only connection failed to ${participantName}`);
          setConnectionStatus('failed');
        }
      };
      
      // Add stream tracks
      if (currentStreamRef.current) {
        currentStreamRef.current.getTracks().forEach(track => {
          console.log(`‚ûï Adding track to TURN-only connection for ${participantName}:`, track.kind);
          pc.addTrack(track, currentStreamRef.current!);
        });
        
        // Create TURN-optimized offer
        const offer = await pc.createOffer({
          offerToReceiveAudio: true,
          offerToReceiveVideo: true,
          iceRestart: true,
          voiceActivityDetection: false
        });
        
        await pc.setLocalDescription(offer);
        
        console.log(`üì§ Sending TURN-only offer to ${participantName}`);
        if (socketRef.current) {
          socketRef.current.emit('webrtc-offer', {
            roomId,
            offer,
            targetId: participantId,
            turnOnly: true
          });
        }
      }
    } catch (error) {
      console.error(`‚ùå Failed to create TURN-only connection to ${participantName}:`, error);
    }
  };

  const debugStream = () => {
    console.log('üîß Manual video fix triggered');
    console.log('Debug info:', { 
      isPresenting, 
      hasCurrentStream: !!currentStreamRef.current,
      remoteStreamsCount: remoteStreams.size,
      participants: participants.map(p => ({ name: p.name, isPresenting: p.isPresenting }))
    });
    
    if (isPresenting && currentStreamRef.current && videoContainerRef.current) {
      // Fix presenter's own video - never clear remote videos
      const videoElement = createVideoElement(currentStreamRef.current);
      videoElement.id = 'presenter-video';
      videoElement.style.position = 'absolute';
      videoElement.style.top = '0';
      videoElement.style.left = '0';
      videoElement.style.width = '100%';
      videoElement.style.height = '100%';
      videoElement.style.zIndex = '1';
      
      // Remove existing presenter video if any
      const existingPresenterVideo = videoContainerRef.current.querySelector('#presenter-video');
      if (existingPresenterVideo) {
        existingPresenterVideo.remove();
      }
      
      videoContainerRef.current.appendChild(videoElement);
      
      videoElement.play().then(() => {
        console.log('‚úÖ Presenter video fix successful');
        setStreamError(null);
      }).catch((error) => {
        console.error('‚ùå Presenter video fix failed:', error);
        setStreamError('Video playback issue - try refreshing the page');
      });
    } else if (!isPresenting && remoteStreams.size > 0 && videoContainerRef.current) {
      // Fix viewer's remote video - ensure it stays in DOM
      const firstRemoteStream = Array.from(remoteStreams.values())[0];
      const firstRemotePeerId = Array.from(remoteStreams.keys())[0];
      
      // Check if remote video already exists
      let existingRemoteVideo = videoContainerRef.current.querySelector(`#remote-video-${firstRemotePeerId}`) as HTMLVideoElement;
      
      if (!existingRemoteVideo) {
        // Only clear if no remote videos exist
        const hasRemoteVideos = videoContainerRef.current.querySelector('[id^="remote-video-"]');
        if (!hasRemoteVideos) {
          videoContainerRef.current.innerHTML = '';
        }
        
        // Create new remote video element without clearing existing ones (unmuted for audio)
        const videoElement = createVideoElement(firstRemoteStream, true);
        videoElement.id = `remote-video-${firstRemotePeerId}`;
        videoElement.style.position = 'absolute';
        videoElement.style.top = '0';
        videoElement.style.left = '0';
        videoElement.style.width = '100%';
        videoElement.style.height = '100%';
        videoElement.style.zIndex = '1';
        
        videoContainerRef.current.appendChild(videoElement);
        existingRemoteVideo = videoElement;
      } else {
        // Update existing video with fresh stream
        existingRemoteVideo.srcObject = firstRemoteStream;
      }
      
      existingRemoteVideo.play().then(() => {
        console.log('‚úÖ Viewer remote video fix successful');
        setStreamError(null);
      }).catch((error) => {
        console.error('‚ùå Viewer remote video fix failed:', error);
        setStreamError('Click the video area to enable playback');
      });
    } else {
      console.log('‚ÑπÔ∏è No video to fix');
    }
  };

  // Join Modal
  if (showJoinModal) {
    return (
      <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div className="bg-white rounded-lg shadow-2xl p-8 w-full max-w-md mx-4 border border-gray-200">
          <div className="text-center mb-6">
            <div className="w-16 h-16 bg-blue-600 rounded-full flex items-center justify-center mx-auto mb-4">
              <Monitor className="w-8 h-8 text-white" />
            </div>
            <h1 className="text-2xl font-bold text-gray-900 mb-2">Airavata Technologies</h1>
            <h2 className="text-lg font-semibold text-gray-700">Screen Share Pro</h2>
            <p className="text-sm text-gray-500 mt-2">Professional screen sharing solution</p>
          </div>
          
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Your Name
              </label>
              <input
                type="text"
                value={userName}
                onChange={(e) => setUserName(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 rounded-md bg-white text-gray-900 focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                placeholder="Enter your name"
              />
            </div>
            
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Room ID
              </label>
              <div className="flex gap-2">
                <input
                  type="text"
                  value={roomId}
                  onChange={(e) => setRoomId(e.target.value.toUpperCase())}
                  className="flex-1 px-3 py-2 border border-gray-300 rounded-md bg-white text-gray-900 focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                  placeholder="Enter room ID"
                />
                <button
                  onClick={generateRoomId}
                  className="px-4 py-2 bg-gray-500 hover:bg-gray-600 text-white rounded-md transition-colors"
                >
                  Generate
                </button>
              </div>
            </div>
            
            <div className="flex gap-2">
              <button
                onClick={joinRoom}
                disabled={!roomId.trim() || !userName.trim()}
                className="flex-1 px-4 py-3 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-400 text-white rounded-md transition-colors font-medium"
              >
                Join Room
              </button>
            </div>
            
            <div className="mt-6 pt-4 border-t border-gray-200 text-center">
              <p className="text-xs text-gray-500">
                ¬© 2025 Airavata Technologies. All rights reserved.
              </p>
            </div>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-100 dark:bg-gray-900">
      {/* Header */}
      <header className="bg-white dark:bg-gray-800 shadow-sm border-b border-gray-200 dark:border-gray-700">
        <div className="max-w-7xl mx-auto px-4 py-4 flex items-center justify-between">
          <div className="flex items-center gap-4">
            <Monitor className="w-8 h-8 text-blue-600" />
            <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Screen Share Pro</h1>
            <div className="flex items-center gap-4">
              <div className="flex items-center gap-2 px-3 py-1 bg-green-100 dark:bg-green-900 rounded-full">
                <div className="w-2 h-2 bg-green-500 rounded-full"></div>
                <span className="text-sm text-green-700 dark:text-green-300">Room: {roomId}</span>
              </div>
              <div className="flex items-center gap-2 px-3 py-1 bg-blue-100 dark:bg-blue-900 rounded-full">
                <span className="text-sm text-blue-700 dark:text-blue-300">Free & Unlimited</span>
              </div>
              {crossNetworkMode && (
                <div className="flex items-center gap-2 px-3 py-1 bg-purple-100 dark:bg-purple-900 rounded-full">
                  <div className="w-2 h-2 bg-purple-500 rounded-full"></div>
                  <span className="text-sm text-purple-700 dark:text-purple-300">Cross-Network Mode</span>
                </div>
              )}
              {turnServerStatus === 'available' && (
                <div className="flex items-center gap-2 px-3 py-1 bg-green-100 dark:bg-green-900 rounded-full">
                  <div className="w-2 h-2 bg-green-500 rounded-full"></div>
                  <span className="text-sm text-green-700 dark:text-green-300">TURN Ready</span>
                </div>
              )}
            </div>
          </div>
          
          <div className="flex items-center gap-2">
            <button
              onClick={copyRoomId}
              className="flex items-center gap-2 px-3 py-2 text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md transition-colors"
            >
              {copied ? <Check className="w-4 h-4" /> : <Copy className="w-4 h-4" />}
              {copied ? 'Copied!' : 'Copy Room ID'}
            </button>
            <button
              onClick={leaveRoom}
              className="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-md transition-colors"
            >
              Leave Room
            </button>
          </div>
        </div>
      </header>

      <div className="max-w-7xl mx-auto p-4 grid grid-cols-1 lg:grid-cols-4 gap-6">
        {/* Main Screen Share Area */}
        <div className="lg:col-span-3">
          <div className="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 p-6">
            <div className="flex items-center justify-between mb-4">
              <h2 className="text-xl font-semibold text-gray-900 dark:text-white">Screen Share</h2>
              
              <div className="flex items-center gap-2">
                <button
                  onClick={() => setShowSettings(!showSettings)}
                  className="p-2 rounded-md transition-colors bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-gray-600"
                >
                  <Settings className="w-4 h-4" />
                </button>
                <button
                  onClick={() => {
                    setAudioEnabled(!audioEnabled);
                    // If currently sharing, restart with new audio setting
                    if (isPresenting && currentStreamRef.current) {
                      const tracks = currentStreamRef.current.getAudioTracks();
                      tracks.forEach(track => track.enabled = !audioEnabled);
                    }
                  }}
                  className={`p-2 rounded-md transition-colors ${
                    audioEnabled 
                      ? 'bg-green-100 dark:bg-green-900 text-green-600 dark:text-green-400'
                      : 'bg-red-100 dark:bg-red-900 text-red-600 dark:text-red-400'
                  }`}
                  title={audioEnabled ? 'Mute microphone' : 'Unmute microphone'}
                >
                  {audioEnabled ? <Mic className="w-4 h-4" /> : <MicOff className="w-4 h-4" />}
                </button>

                
                {/* Recording Controls */}
                {isPresenting && (
                  <>
                    {!isRecording ? (
                      <button
                        onClick={startRecording}
                        className="flex items-center gap-2 px-3 py-2 bg-red-600 hover:bg-red-700 text-white rounded-md transition-colors text-sm"
                      >
                        <Play className="w-4 h-4" />
                        Record
                      </button>
                    ) : (
                      <button
                        onClick={stopRecording}
                        className="flex items-center gap-2 px-3 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-md transition-colors text-sm"
                      >
                        <Pause className="w-4 h-4" />
                        Stop Rec
                      </button>
                    )}
                    {recordedChunks.length > 0 && (
                      <button
                        onClick={downloadRecording}
                        className="flex items-center gap-2 px-3 py-2 bg-green-600 hover:bg-green-700 text-white rounded-md transition-colors text-sm"
                      >
                        <Download className="w-4 h-4" />
                        Download
                      </button>
                    )}
                  </>
                )}
                
                {!isPresenting ? (
                  <div className="flex items-center gap-2">
                    <button
                      onClick={startScreenShare}
                      className="flex items-center gap-2 px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md transition-colors"
                    >
                      <Monitor className="w-4 h-4" />
                      Share Screen
                    </button>
                    <button
                      onClick={startCameraShare}
                      className="flex items-center gap-2 px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded-md transition-colors"
                    >
                      <Video className="w-4 h-4" />
                      Share Camera
                    </button>
                  </div>
                ) : (
                  <div className="flex items-center gap-2">
                    <button
                      onClick={sharingCamera ? stopCameraShare : stopScreenShare}
                      className="flex items-center gap-2 px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-md transition-colors"
                    >
                      <Square className="w-4 h-4" />
                      {sharingCamera ? 'Stop Camera' : 'Stop Screen'}
                    </button>
                  </div>
                )}
                {(isPresenting || remoteStreams.size > 0) && (
                  <>
                    <button
                      onClick={toggleFullScreen}
                      className="flex items-center gap-2 px-3 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded-md transition-colors text-sm"
                    >
                      {isFullScreen ? <Minimize className="w-4 h-4" /> : <Maximize className="w-4 h-4" />}
                      {isFullScreen ? 'Exit Full' : 'Full Screen'}
                    </button>
                    <button
                      onClick={debugStream}
                      className="px-3 py-2 bg-yellow-600 hover:bg-yellow-700 text-white rounded-md transition-colors text-sm"
                    >
                      Fix Video
                    </button>
                  </>
                )}
              </div>
            </div>
            
            {/* Settings Panel */}
            {showSettings && (
              <div className="mb-4 p-4 bg-gray-50 dark:bg-gray-700 rounded-lg border border-gray-200 dark:border-gray-600">
                <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-3">Settings</h3>
                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                      Frame Rate (FPS)
                    </label>
                    <select
                      value={fps}
                      onChange={(e) => setFps(Number(e.target.value))}
                      disabled={isPresenting}
                      className="w-full px-3 py-2 text-sm border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-800 text-gray-900 dark:text-white disabled:bg-gray-100 dark:disabled:bg-gray-600"
                    >
                      <option value={15}>15 FPS (Low)</option>
                      <option value={24}>24 FPS (Cinematic)</option>
                      <option value={30}>30 FPS (Standard)</option>
                      <option value={45}>45 FPS (High)</option>
                      <option value={60}>60 FPS (Ultra)</option>
                    </select>
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                      Quality
                    </label>
                    <select
                      value={quality}
                      onChange={(e) => setQuality(e.target.value)}
                      disabled={isPresenting}
                      className="w-full px-3 py-2 text-sm border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-800 text-gray-900 dark:text-white disabled:bg-gray-100 dark:disabled:bg-gray-600"
                    >
                      <option value="1080p">1080p HD</option>
                      <option value="720p">720p</option>
                      <option value="480p">480p</option>
                    </select>
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                      Usage
                    </label>
                    <div className="px-3 py-2 text-sm bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200 rounded-md border border-green-200 dark:border-green-700">
                      ‚úÖ Unlimited & Free
                    </div>
                  </div>
                </div>
                
                <div className="mt-4 grid grid-cols-1 md:grid-cols-3 gap-4">
                  <div className="flex items-center justify-between p-3 bg-white dark:bg-gray-800 rounded-md border border-gray-200 dark:border-gray-600">
                    <span className="text-sm font-medium text-gray-700 dark:text-gray-300">Screen Audio</span>
                    <button
                      onClick={() => setAudioEnabled(!audioEnabled)}
                      disabled={isPresenting}
                      className={`w-12 h-6 rounded-full transition-colors ${
                        audioEnabled ? 'bg-blue-600' : 'bg-gray-300 dark:bg-gray-600'
                      } disabled:opacity-50`}
                    >
                      <div className={`w-5 h-5 bg-white rounded-full shadow-md transform transition-transform ${
                        audioEnabled ? 'translate-x-6' : 'translate-x-0'
                      }`} />
                    </button>
                  </div>
                  <div className="flex items-center justify-between p-3 bg-white dark:bg-gray-800 rounded-md border border-gray-200 dark:border-gray-600">
                    <span className="text-sm font-medium text-gray-700 dark:text-gray-300">Microphone</span>
                    <button
                      onClick={() => setMicrophoneEnabled(!microphoneEnabled)}
                      disabled={isPresenting}
                      className={`w-12 h-6 rounded-full transition-colors ${
                        microphoneEnabled ? 'bg-green-600' : 'bg-gray-300 dark:bg-gray-600'
                      } disabled:opacity-50`}
                    >
                      <div className={`w-5 h-5 bg-white rounded-full shadow-md transform transition-transform ${
                        microphoneEnabled ? 'translate-x-6' : 'translate-x-0'
                      }`} />
                    </button>
                  </div>
                  <div className="flex items-center justify-between p-3 bg-white dark:bg-gray-800 rounded-md border border-gray-200 dark:border-gray-600">
                    <span className="text-sm font-medium text-gray-700 dark:text-gray-300">Show Cursor</span>
                    <button
                      onClick={() => setShowCursor(!showCursor)}
                      disabled={isPresenting}
                      className={`w-12 h-6 rounded-full transition-colors ${
                        showCursor ? 'bg-blue-600' : 'bg-gray-300 dark:bg-gray-600'
                      } disabled:opacity-50`}
                    >
                      <div className={`w-5 h-5 bg-white rounded-full shadow-md transform transition-transform ${
                        showCursor ? 'translate-x-6' : 'translate-x-0'
                      }`} />
                    </button>
                  </div>
                </div>
                
                {isPresenting && (
                  <div className="mt-4 p-3 bg-blue-50 dark:bg-blue-900 rounded-md border border-blue-200 dark:border-blue-700">
                    <p className="text-sm text-blue-800 dark:text-blue-200">
                      <strong>Note:</strong> Settings can only be changed when not sharing. Stop sharing to modify settings.
                    </p>
                  </div>
                )}
              </div>
            )}
            
            {/* Video Container */}
            <div 
              className={`relative bg-gray-900 rounded-lg overflow-hidden min-h-[400px] flex items-center justify-center cursor-pointer ${
                isFullScreen ? 'fixed inset-0 z-50 rounded-none min-h-screen' : ''
              }`}
              onClick={() => {
                // Enable video playback on container click
                const video = videoContainerRef.current?.querySelector('video');
                if (video && video.paused) {
                  video.play().then(() => {
                    console.log('‚úÖ Video enabled by user click');
                    setStreamError(null);
                  }).catch(console.error);
                }
              }}
            >
              {isPresenting ? (
                <div className={`relative w-full h-full ${isFullScreen ? 'min-h-screen' : ''}`}>
                  <div
                    ref={videoContainerRef}
                    className={`w-full h-full ${isFullScreen ? 'min-h-screen' : 'min-h-[400px]'} flex items-center justify-center`}
                  />
                  <div className="absolute top-2 left-2 flex gap-2">
                    <div className="bg-red-500 text-white px-2 py-1 rounded text-xs">
                      üî¥ {sharingCamera ? 'CAMERA' : 'SCREEN'} ({fps} FPS) - {userName}
                    </div>
                    {microphoneEnabled && (
                      <div className="bg-green-500 text-white px-2 py-1 rounded text-xs">
                        üé§ MIC ON
                      </div>
                    )}
                    <div className={`text-white px-2 py-1 rounded text-xs ${
                      connectionStatus === 'connected' ? 'bg-green-500' : 
                      connectionStatus === 'connecting' ? 'bg-yellow-500' : 
                      connectionStatus === 'failed' ? 'bg-red-500' : 'bg-blue-500'
                    }`}>
                      {connectionStatus === 'connected' ? 'üåê CONNECTED' : 
                       connectionStatus === 'connecting' ? 'üîÑ CONNECTING' : 
                       connectionStatus === 'failed' ? '‚ùå FAILED' : 'üåê UNIVERSAL'}
                    </div>
                    {turnServerStatus === 'available' && (
                      <div className="bg-purple-500 text-white px-2 py-1 rounded text-xs">
                        üîÑ TURN
                      </div>
                    )}
                    {isRecording && (
                      <div className="bg-red-600 text-white px-2 py-1 rounded text-xs animate-pulse">
                        ‚è∫ REC
                      </div>
                    )}
                  </div>
                  {isFullScreen && (
                    <div className="absolute top-2 right-2 flex gap-2">
                      <button
                        onClick={toggleFullScreen}
                        className="bg-black bg-opacity-50 text-white px-3 py-2 rounded-md hover:bg-opacity-70 transition-colors flex items-center gap-1"
                      >
                        <Minimize className="w-4 h-4" />
                        Exit Full Screen
                      </button>
                    </div>
                  )}
                  {streamError && (
                    <div className="absolute bottom-2 left-2 right-2 bg-red-600 text-white px-3 py-2 rounded text-sm">
                      {streamError}
                    </div>
                  )}
                </div>
              ) : remoteStreams.size > 0 ? (
                <div className={`relative w-full h-full ${isFullScreen ? 'min-h-screen' : ''}`}>
                  <div
                    ref={videoContainerRef}
                    className={`w-full h-full ${isFullScreen ? 'min-h-screen' : 'min-h-[400px]'} flex items-center justify-center`}
                  />
                  <div className="absolute top-2 left-2 flex gap-2">
                    <div className="bg-green-500 text-white px-2 py-1 rounded text-xs">
                      üëÅ VIEWING SHARED SCREEN
                    </div>
                  </div>
                  {isFullScreen && (
                    <div className="absolute top-2 right-2 flex gap-2">
                      <button
                        onClick={toggleFullScreen}
                        className="bg-black bg-opacity-50 text-white px-3 py-2 rounded-md hover:bg-opacity-70 transition-colors flex items-center gap-1"
                      >
                        <Minimize className="w-4 h-4" />
                        Exit Full Screen
                      </button>
                    </div>
                  )}
                </div>
              ) : (
                <div className="text-center text-gray-400">
                  <Monitor className="w-16 h-16 mx-auto mb-4 opacity-50" />
                  <p className="text-lg">No screen share active</p>
                  <p className="text-sm opacity-75">
                    {participants.some(p => p.isPresenting) 
                      ? "Connecting to presenter..." 
                      : "Click 'Start Sharing' to begin"
                    }
                  </p>
                </div>
              )}
            </div>
          </div>
        </div>

        {/* Sidebar */}
        <div className="space-y-6">
          {/* Participants */}
          <div className="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 p-4">
            <div className="flex items-center gap-2 mb-4">
              <Users className="w-5 h-5 text-gray-600 dark:text-gray-400" />
              <h3 className="font-semibold text-gray-900 dark:text-white">
                Participants ({participants.length})
              </h3>
            </div>
            <div className="space-y-2">
              {participants.map((participant) => (
                <div
                  key={participant.id}
                  className="flex items-center gap-3 p-2 rounded-md bg-gray-50 dark:bg-gray-700"
                >
                  <div className="w-8 h-8 bg-blue-600 rounded-full flex items-center justify-center text-white text-sm font-medium">
                    {participant.name.charAt(0).toUpperCase()}
                  </div>
                  <div className="flex-1">
                    <p className="text-sm font-medium text-gray-900 dark:text-white">
                      {participant.name}
                      {participant.id === userId && ' (You)'}
                    </p>
                    {participant.isPresenting && (
                      <p className="text-xs text-green-600 dark:text-green-400">Presenting</p>
                    )}
                  </div>
                </div>
              ))}
            </div>
          </div>

          {/* Chat */}
          <div className="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 p-4">
            <div className="flex items-center gap-2 mb-4">
              <MessageCircle className="w-5 h-5 text-gray-600 dark:text-gray-400" />
              <h3 className="font-semibold text-gray-900 dark:text-white">Chat</h3>
            </div>
            
            <div
              ref={chatMessagesRef}
              className="h-64 overflow-y-auto border rounded-md p-3 mb-3 bg-gray-50 dark:bg-gray-700"
            >
              {messages.map((message) => (
                <div key={message.id} className="mb-2">
                  <div className="flex items-start gap-2">
                    <span className={`text-xs font-medium ${
                      message.userId === 'system' 
                        ? 'text-blue-600 dark:text-blue-400'
                        : message.userId === userId
                        ? 'text-green-600 dark:text-green-400'
                        : 'text-gray-600 dark:text-gray-400'
                    }`}>
                      {message.userName}:
                    </span>
                  </div>
                  <p className="text-sm text-gray-900 dark:text-white ml-2">{message.text}</p>
                </div>
              ))}
            </div>
            
            <div className="flex gap-2">
              <input
                type="text"
                value={messageInput}
                onChange={(e) => setMessageInput(e.target.value)}
                onKeyPress={handleKeyPress}
                placeholder="Type a message..."
                className="flex-1 px-3 py-2 text-sm border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
              />
              <button
                onClick={sendMessage}
                disabled={!messageInput.trim()}
                className="px-3 py-2 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-400 text-white rounded-md transition-colors"
              >
                <Send className="w-4 h-4" />
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}